import rclpy
from rclpy.node import Node

from vila_msgs.msg import CaptionWithPose

import os
import time
import shutil
import traceback

from pymilvus import MilvusClient
from pymilvus import DataType

from sentence_transformers import SentenceTransformer
from sentence_transformers.util import cos_sim
from sentence_transformers.quantization import quantize_embeddings


class MemoryBuilder(Node):
    """
    ROS2 node that subscribes to caption data with pose information.

    This node receives caption data generated by the VILA captioner
    and prepares it for future storage in Milvus vector database.
    """

    def __init__(self):
        super().__init__('memory_builder')

        self.get_logger().info('Initializing Memory Builder node...')

        # Statistics
        self.caption_count = 0

        # Database configuration
        self.db_path = "./milvus_demo.db"
        self.collection_name = "robot_memories"

        # Reset database on startup
        self._reset_database()

        # Initialize Milvus client
        try:
            self.get_logger().info('Connecting to Milvus...')
            self.milvus_client = MilvusClient(self.db_path)
            self._setup_collection()
            self.get_logger().info(f'Milvus collection "{self.collection_name}" ready')
        except Exception as e:
            self.get_logger().error(f'Failed to initialize Milvus: {e}')
            self.get_logger().error(traceback.format_exc())
            raise

        # Load embedding model
        try:
            self.get_logger().info('Loading mixedbread-ai/mxbai-embed-large-v1 model...')
            self.embedding_model = SentenceTransformer('mixedbread-ai/mxbai-embed-large-v1')
            self.get_logger().info(
                f'Embedding model loaded (output dim: {self.embedding_model.get_sentence_embedding_dimension()})')
        except Exception as e:
            self.get_logger().error(f'Failed to load embedding model: {e}')
            self.get_logger().error(traceback.format_exc())
            raise

        # Subscribe to caption with pose topic
        self.caption_subscription = self.create_subscription(
            CaptionWithPose,
            '/caption_with_pose',
            self.caption_callback,
            10)
        self.caption_subscription  # prevent unused variable warning

        self.get_logger().info('Memory Builder node initialized successfully')
        self.get_logger().info('Waiting for caption data on /caption_with_pose...')

    def _reset_database(self):
        """
        Reset Milvus database by deleting collection and DB files.
        Called automatically on node startup.
        """
        self.get_logger().info('ðŸ”„ Starting database reset...')

        try:
            # 1. Delete existing collection if it exists
            # if os.path.exists(self.db_path):
            #     try:
            #         temp_client = MilvusClient(self.db_path)
            #         if temp_client.has_collection(self.collection_name):
            #             temp_client.drop_collection(self.collection_name)
            #             self.get_logger().info(f'âœ“ Dropped collection "{self.collection_name}"')
            #         temp_client.close()
            #     except Exception as e:
            #         self.get_logger().warn(f'Could not drop collection: {e}')

            self.get_logger().info('âœ… Database reset complete - starting fresh')

        except Exception as e:
            self.get_logger().error(f'Error during database reset: {e}')
            self.get_logger().error(traceback.format_exc())
            # Continue even if reset fails - will create new DB

    def _setup_collection(self):
        """Set up Milvus collection with proper schema."""

        # Check if collection exists
        if self.milvus_client.has_collection(self.collection_name):
            self.get_logger().info(f'Collection "{self.collection_name}" already exists')
            return

        # Define collection schema
        schema = self.milvus_client.create_schema(
            auto_id=False,
            enable_dynamic_fields=False,
        )

        # Add fields
        schema.add_field(field_name="id", datatype=DataType.VARCHAR,
                         is_primary=True, auto_id=False, max_length=1000)
        schema.add_field(field_name="caption_text", datatype=DataType.VARCHAR, max_length=3000)
        schema.add_field(field_name="caption_embedding", datatype=DataType.FLOAT_VECTOR, dim=1024)
        schema.add_field(field_name="position", datatype=DataType.FLOAT_VECTOR, dim=3)
        schema.add_field(field_name="theta", datatype=DataType.FLOAT, dim=1)
        schema.add_field(field_name="time", datatype=DataType.FLOAT_VECTOR, dim=2)

        # Create index parameters for vector fields
        index_params = self.milvus_client.prepare_index_params()

        # Index for caption_embedding (IVF_FLAT for semantic search)
        index_params.add_index(
            field_name="caption_embedding",
            metric_type="L2",
            index_type="IVF_FLAT",
            params={"nlist": 1024}
        )

        # Index for position vector
        index_params.add_index(
            field_name="position",
            metric_type="L2",
            index_type="IVF_FLAT",
            params={"nlist": 2}
        )

        # Index for time vector
        index_params.add_index(
            field_name="time",
            metric_type="L2",
            index_type="IVF_FLAT",
            params={"nlist": 2}
        )

        # Create collection
        self.milvus_client.create_collection(
            collection_name=self.collection_name,
            schema=schema,
            index_params=index_params
        )

        self.get_logger().info(f'Created collection "{self.collection_name}" with schema')

    def caption_callback(self, msg):
        """
        Callback function for /caption_with_pose topic.

        Args:
            msg (CaptionWithPose): Message containing caption and robot pose
        """
        try:
            self.caption_count += 1

            # Log received data
            self.get_logger().info('=' * 80)
            self.get_logger().info(f'Caption #{self.caption_count} received:')
            self.get_logger().info(f'  Caption: "{msg.caption}"')
            self.get_logger().info(
                f'  Position: ({msg.position_x:.3f}, {msg.position_y:.3f}, {msg.position_z:.3f})')
            self.get_logger().info(f'  Orientation (theta): {msg.theta:.3f} rad')
            self.get_logger().info(f'  Timestamp: {msg.timestamp.sec}.{msg.timestamp.nanosec}')
            self.get_logger().info(f'  Image count: {msg.image_count}')
            self.get_logger().info('=' * 80)

            # Store to Milvus vector database
            self.store_to_milvus(msg)

        except Exception as e:
            self.get_logger().error(f'Error in caption callback: {e}')
            self.get_logger().error(traceback.format_exc())

    def store_to_milvus(self, msg):
        """
        Store caption data with embeddings to Milvus vector database.

        Args:
            msg (CaptionWithPose): Caption data to store

        Generates:
        - caption_embedding: 1024-dim vector from mixedbread-ai model
        - position: 2-dim vector [x, y]
        - time: 2-dim vector [normalized seconds, fractional nanoseconds]
        """
        try:
            # 0. Generate unique ID
            id_str = str(time.time())

            # 1. Generate caption embedding
            caption_embedding = self.embedding_model.encode(
                msg.caption,
                normalize_embeddings=True,
                convert_to_tensor=False
            ).tolist()

            # 2. Prepare position vector (3D: x, y, z)
            position_vector = [float(msg.position_x), float(msg.position_y), float(msg.position_z)]

            # 3. Prepare time vector (2D: seconds, fractional)
            timestamp_seconds = float(msg.timestamp.sec)
            timestamp_fractional = float(msg.timestamp.nanosec) * 1e-9
            time_vector = [
                timestamp_seconds / 1e9,  # Normalize to billions of seconds scale
                timestamp_fractional
            ]

            # 4. Prepare data for insertion
            data = [{
                "id": id_str,
                "caption_embedding": caption_embedding,
                "caption_text": msg.caption,
                "position": position_vector,
                "theta": float(msg.theta),
                "time": time_vector,
            }]

            # 5. Insert into Milvus
            result = self.milvus_client.insert(
                collection_name=self.collection_name,
                data=data
            )

            self.get_logger().info(
                f'âœ“ Stored to Milvus: "{msg.caption[:50]}..." '
                f'(ID: {result["ids"][0] if result.get("ids") else "N/A"})'
            )

        except Exception as e:
            # Log error but continue execution (as per user preference)
            self.get_logger().error(f'Failed to store to Milvus: {e}')
            self.get_logger().error(traceback.format_exc())


def main(args=None):
    """Main entry point for the memory_builder node."""
    rclpy.init(args=args)

    memory_builder = MemoryBuilder()

    try:
        rclpy.spin(memory_builder)
    except KeyboardInterrupt:
        memory_builder.get_logger().info('Keyboard interrupt, shutting down...')
    finally:
        memory_builder.get_logger().info(f'Total captions received: {memory_builder.caption_count}')
        memory_builder.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

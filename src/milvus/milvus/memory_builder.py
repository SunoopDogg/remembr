import rclpy
from rclpy.node import Node

from vila_msgs.msg import CaptionWithPose

import sys
import argparse
import traceback

from .config import DatabaseConfig, EMBEDDING_MODEL
from .services import MilvusService, EmbeddingService, DataPipeline


class MemoryBuilder(Node):
    """
    ROS2 node that subscribes to caption data with pose information.

    This node receives caption data generated by the VILA captioner
    and stores it in Milvus vector database.
    """

    def __init__(self, reset_db: bool = False):
        super().__init__('memory_builder')

        self.get_logger().info('Initializing Memory Builder node...')

        # Statistics
        self.caption_count = 0

        # Initialize configuration
        self.db_config = DatabaseConfig()
        self.db_config.validate()
        self.get_logger().info(f'Database path: {self.db_config.db_path}')

        # Initialize services
        self.milvus_service = MilvusService(self.db_config, self.get_logger())
        self.embedding_service = EmbeddingService(EMBEDDING_MODEL, self.get_logger())
        self.data_pipeline = DataPipeline(self.embedding_service)

        # Setup services
        self._initialize_services(reset_db)

        # Subscribe to caption with pose topic
        self._caption_subscription = self.create_subscription(
            CaptionWithPose,
            '/caption_with_pose',
            self.caption_callback,
            10
        )

        self.get_logger().info('Memory Builder node initialized successfully')
        self.get_logger().info('Waiting for caption data on /caption_with_pose...')

    def _log_error(self, context: str, error: Exception, reraise: bool = True) -> None:
        """
        Log error with traceback.

        Args:
            context: Error context description
            error: Exception that occurred
            reraise: Whether to re-raise the exception after logging
        """
        self.get_logger().error(f'{context}: {error}')
        self.get_logger().error(traceback.format_exc())
        if reraise:
            raise

    def _initialize_services(self, reset_db: bool) -> None:
        """Initialize all services."""
        try:
            # Initialize Milvus
            self.milvus_service.connect()

            if reset_db:
                self.milvus_service.reset_database()
            else:
                self.milvus_service.setup_collection()

            self.get_logger().info(
                f'Milvus collection "{self.db_config.collection_name}" ready')

            # Load embedding model
            self.embedding_service.load_model()

        except Exception as e:
            self._log_error('Service initialization failed', e)

    def caption_callback(self, msg: CaptionWithPose) -> None:
        """
        Callback function for /caption_with_pose topic.

        Args:
            msg (CaptionWithPose): Message containing caption and robot pose
        """
        try:
            self.caption_count += 1

            # Concise info logging
            self.get_logger().info(
                f'Caption #{self.caption_count}: "{msg.caption[:30]}..." '
                f'at ({msg.position_x:.1f}, {msg.position_y:.1f})'
            )

            # Detailed debug logging (only if debug level enabled)
            self.get_logger().debug('Detailed caption data:')
            self.get_logger().debug(f'  Full caption: "{msg.caption}"')
            self.get_logger().debug(
                f'  Position: ({msg.position_x:.3f}, {msg.position_y:.3f}, {msg.position_z:.3f})')
            self.get_logger().debug(f'  Orientation (theta): {msg.theta:.3f} rad')
            self.get_logger().debug(f'  Timestamp: {msg.timestamp.sec}.{msg.timestamp.nanosec}')
            self.get_logger().debug(f'  Image count: {msg.image_count}')

            # Store to Milvus
            self._store_to_milvus(msg)

        except Exception as e:
            self._log_error('Error in caption callback', e, reraise=False)

    def _store_to_milvus(self, msg: CaptionWithPose) -> None:
        """
        Store caption data to Milvus vector database.

        Args:
            msg (CaptionWithPose): Caption data to store

        Uses dataclass pipeline:
        1. CaptionData.from_ros_msg() - Extract ROS message data
        2. VectorData.from_caption_data() - Compute embeddings and vectors
        3. MilvusMemoryRecord.from_caption_and_vectors() - Create database record
        4. Insert into Milvus database
        """
        try:
            # Transform ROS message to Milvus record
            record = self.data_pipeline.process_ros_message(msg)

            # Insert into Milvus
            result = self.milvus_service.insert_record(record)

            self.get_logger().info(
                f'âœ“ Stored to Milvus: "{record.caption_text[:50]}..." '
                f'(ID: {result["ids"][0] if result.get("ids") else "N/A"})'
            )

        except Exception as e:
            # Log error but continue execution
            self._log_error('Failed to store to Milvus', e, reraise=False)

    def destroy_node(self) -> None:
        """Clean up resources when node is destroyed."""
        self.get_logger().info('Cleaning up resources...')

        # Close Milvus connection
        if hasattr(self, 'milvus_service'):
            try:
                self.milvus_service.close()
                self.get_logger().info('Milvus service closed')
            except Exception as e:
                self.get_logger().warning(f'Error closing Milvus service: {e}')

        # Clean up embedding model
        if hasattr(self, 'embedding_service'):
            try:
                self.embedding_service.cleanup()
                self.get_logger().info('Embedding service cleaned up')
            except Exception as e:
                self.get_logger().warning(f'Error cleaning up embedding service: {e}')

        # Clean up data pipeline
        if hasattr(self, 'data_pipeline'):
            del self.data_pipeline

        super().destroy_node()


def main(args: list[str] | None = None) -> None:
    """Main entry point for the memory_builder node."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='Memory Builder Node - Stores robot captions in Milvus')
    parser.add_argument('--reset', action='store_true',
                        help='Reset database on startup (deletes existing data)')

    # Separate ROS args from our custom args
    if args is None:
        args = sys.argv[1:]

    # Filter out ROS-specific arguments (starting with __name:=, __node:=, etc.)
    custom_args = [arg for arg in args if not arg.startswith('__')]
    parsed_args = parser.parse_args(custom_args)

    # Initialize ROS2 with original args
    rclpy.init(args=args if args != sys.argv[1:] else None)

    memory_builder = None
    try:
        memory_builder = MemoryBuilder(reset_db=parsed_args.reset)
        rclpy.spin(memory_builder)
    except KeyboardInterrupt:
        if memory_builder:
            memory_builder.get_logger().info('Keyboard interrupt, shutting down...')
    except Exception as e:
        if memory_builder:
            memory_builder.get_logger().error(f'Unexpected error: {e}')
            memory_builder.get_logger().error(traceback.format_exc())
        raise
    finally:
        if memory_builder:
            memory_builder.get_logger().info(
                f'Total captions received: {memory_builder.caption_count}')
            memory_builder.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
